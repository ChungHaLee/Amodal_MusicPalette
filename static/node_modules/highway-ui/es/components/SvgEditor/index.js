function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

import React from 'react';
import PropTypes from 'prop-types';
import { Menu, Dropdown, Popover, Tooltip } from 'antd';
import isEqual from 'lodash/isEqual';
import subjx from 'subjx';
import { GithubPicker } from 'react-color';
import PlainDraggable from 'plain-draggable';
import cx from 'classnames';
import 'subjx/dist/style/subjx.css';
import './index.less';
import parseMatrixToObject from '../../utils/parseMatrixToObject';
import calcPolygonWidthHeight from '../../utils/calcPolygonWidthHeight';
import parseMatrixToArray from '../../utils/parseMatrixToArray';
var PLACEHOLDER = 'placeholder';
var colorLists = ['#00ff00', '#ffff00', '#f10f0f'];
var roadConfig = {
  stroke: '#00ff00'
};
var textConfig = {
  transform: '',
  text: '',
  x: 0,
  y: 0,
  fill: '#fff',
  fontSize: 16,
  writingMode: 'lr' // lr: 横排, tb: 竖排

};
var paramConfig = {
  transform: '',
  text: '',
  x: 0,
  y: 0,
  fill: '#fff',
  fontSize: 16,
  writingMode: 'lr' // lr: 横排, tb: 竖排

};
var rectConfig = {
  transform: '',
  x: 0,
  y: 0,
  width: 50,
  height: 50,
  fill: '#ccc',
  radius: 0
};
var ovalConfig = {
  transform: '',
  cx: 25,
  cy: 25,
  r: 50,
  fill: 'red'
};
var polygonConfig = {
  transform: '',
  points: '0,50 50,50 25,0',
  fill: 'orange'
};
var lineConfig = {
  transform: '',
  x1: 0,
  y1: 100,
  x2: 83.5,
  y2: 0.5,
  stroke: 'blue',
  strokeWidth: 4
};
var dashedLineConfig = {
  transform: '',
  x1: 0,
  y1: 0,
  x2: 83.5,
  y2: 0.5,
  stroke: '#ffff00',
  strokeWidth: 4,
  strokeDasharray: '10, 5'
};
var imageConfig = {
  url: '',
  transform: '',
  width: 50,
  height: 50,
  x: 0,
  y: 0
};

function isNumber(number) {
  return Object.prototype.toString.call(number) === '[object Number]';
}

var SvgEditor = /*#__PURE__*/function (_React$Component) {
  _inherits(SvgEditor, _React$Component);

  var _super = _createSuper(SvgEditor);

  function SvgEditor(props) {
    var _this2;

    _classCallCheck(this, SvgEditor);

    _this2 = _super.call(this, props);
    _this2.svgRef = void 0;
    _this2.dragInsList = void 0;
    _this2.propTypes = void 0;
    _this2.drawData = void 0;

    _this2.mobxUseCallback = function (b) {
      var a = _this2.addParagraph(b);
    };

    _this2.addParagraph = function (drawData) {
      drawData.map(function (items) {
        var type = items.type,
            startIoiId = items.startIoiId,
            endIoiId = items.endIoiId,
            pointIoiIds = items.pointIoiIds;
        if (type !== 'road') return;
        var ioiList = pointIoiIds.filter(function (item) {
          return item.ioiId;
        });

        if (ioiList.length > 0) {
          pointIoiIds.forEach(function (item, pointIdx) {
            if (item.ioiId) {
              var idx = ioiList.findIndex(function (a) {
                return a.ioiId === item.ioiId;
              });

              if (idx === ioiList.length - 1) {
                item.paragraph = "".concat(item.ioiId, "-").concat(endIoiId.ioiId);
              } else {
                item.paragraph = "".concat(item.ioiId, "-").concat(ioiList[idx + 1].ioiId);
              }
            } else {
              if (pointIdx === 0) {
                item.paragraph = "".concat(startIoiId.ioiId, "-").concat(ioiList[0].ioiId);
              } else {
                item.paragraph = _this2.getPrevParagraph(pointIoiIds, startIoiId, pointIdx, ioiList);
              }
            }
          });
          startIoiId.paragraph = "".concat(startIoiId.ioiId, "-").concat(ioiList[0].ioiId);
        } else {
          pointIoiIds.forEach(function (item) {
            item.paragraph = "".concat(startIoiId.ioiId, "-").concat(endIoiId.ioiId);
          });
          startIoiId.paragraph = "".concat(startIoiId.ioiId, "-").concat(endIoiId.ioiId);
        }
      }); // }

      return drawData;
    };

    _this2.getPrevParagraph = function (pointIoiIds, startIoiId, pointIdx, ioiList) {
      var prevIoiParagraph = '';

      for (var i = pointIdx; i >= 0; i--) {
        if (pointIoiIds[i].ioiId) {
          prevIoiParagraph = pointIoiIds[i].paragraph;
          break;
        }
      }

      return prevIoiParagraph || "".concat(startIoiId.interId, "-").concat(ioiList[0].ioiId);
    };

    _this2.addOutSideClickListener = function (e) {
      if (!_this2.svgRef.current.contains(e.target)) {
        _this2.handleInitWrap();
      }
    };

    _this2.deleteCircle = function (ele) {
      var drawData = _this2.state.drawData;
      var onDataChange = _this2.props.onDataChange;
      var index = ele.getAttribute('data-index');
      var currentIoi = ele.getAttribute('data-ioiid');
      var parentIndex = ele.getAttribute('data-parentindex'); // let flag = false
      // flag = drawData.some(item => {
      // let index = item.pointIoiIds.findIndex(item => { return index === item})

      if (!currentIoi && index > 0) {
        drawData[parentIndex].pointIoiIds.splice(index - 1, 1);
      } //   return true
      // })
      // flag && this.setState({drawData})


      onDataChange && onDataChange(drawData); // handleChangeRoadStroke(drawData)
    };

    _this2.handleMenuToTop = function (item, index) {
      var onDataChange = _this2.props.onDataChange;
      var newData = JSON.parse(JSON.stringify(_this2.state.drawData));
      var maxZIndex = Math.max.apply(Math, _toConsumableArray(newData.map(function (v) {
        return v.zIndex;
      })));
      maxZIndex = maxZIndex >= 0 ? maxZIndex : 0;
      newData[index].zIndex = maxZIndex + 1;

      _this2.handleInitWrap();

      onDataChange && onDataChange(newData);
    };

    _this2.handleMenuDelete = function (item, index) {
      var onDataChange = _this2.props.onDataChange;
      var newData = JSON.parse(JSON.stringify(_this2.state.drawData));
      newData.splice(index, 1);

      _this2.handleInitWrap();

      onDataChange && onDataChange(newData);
    };

    _this2.handleInitWrap = function () {
      _this2.dragInsList.forEach(function (v) {
        return v.disable();
      });

      _this2.dragInsList = [];
    };

    _this2.chooseColor = function (v, type, paragraph, parentIndex) {
      return /*#__PURE__*/React.createElement(GithubPicker, {
        color: v.stroke,
        colors: colorLists,
        triangle: "hide",
        className: "svg-edit-picker",
        onChange: function onChange(value) {
          _this2.handleChangeRoad(v, _this2.getColor(value), type, paragraph, parentIndex);
        }
      });
    };

    _this2.getParagraphIoiList = function (val) {
      if (val) {
        var _val$split = val.split('-'),
            _val$split2 = _slicedToArray(_val$split, 2),
            startIoiId = _val$split2[0],
            endIoiid = _val$split2[1];

        return {
          startIoiId: startIoiId,
          endIoiid: endIoiid
        };
      } else {
        return {};
      }
    };

    _this2.handleChangeRoad = function (v, colorValue, type, paragraph, parentIndex) {
      var drawData = _this2.state.drawData;
      var onDataChange = _this2.props.onDataChange; // drawData.forEach(items => {

      var _drawData$parentIndex = drawData[parentIndex],
          startIoiId = _drawData$parentIndex.startIoiId,
          pointIoiIds = _drawData$parentIndex.pointIoiIds;

      if (startIoiId.paragraph === paragraph) {
        drawData[parentIndex].stroke = colorValue;
        drawData[parentIndex].startIoiId.stroke = colorValue;
        pointIoiIds.forEach(function (item) {
          if (startIoiId.paragraph === item.paragraph) {
            item.stroke = colorValue;
          }
        }); // this.changeLineColor(colorValue)
      } else {
        var middlePointColor = pointIoiIds.filter(function (a) {
          return a.paragraph === paragraph;
        });
        middlePointColor.forEach(function (item) {
          item.stroke = colorValue;
        });
      }

      onDataChange && onDataChange(drawData);
    };

    _this2.getColor = function (value) {
      return value.hex;
    };

    _this2.renderRoad = function (item, parentIndex, screenIdx) {
      var _this2$props = _this2.props,
          width = _this2$props.width,
          height = _this2$props.height;

      var _Object$assign = Object.assign({}, roadConfig, item),
          type = _Object$assign.type,
          stroke = _Object$assign.stroke,
          widths = _Object$assign.widths,
          showTraffic = _Object$assign.showTraffic,
          transform = _Object$assign.transform,
          x1 = _Object$assign.x1,
          x2 = _Object$assign.x2,
          y1 = _Object$assign.y1,
          y2 = _Object$assign.y2,
          startIoiId = _Object$assign.startIoiId,
          endIoiId = _Object$assign.endIoiId,
          pointIoiIds = _Object$assign.pointIoiIds,
          roadScreenIdx = _Object$assign.screenIdx;

      var sortPointIoiIds = [_objectSpread({
        x: x1,
        y: y1,
        type: 'start',
        stroke: stroke
      }, startIoiId)].concat(_toConsumableArray(pointIoiIds), [_objectSpread({
        x: x2,
        y: y2,
        type: 'end',
        stroke: stroke
      }, endIoiId)]);
      var length = sortPointIoiIds.length;
      return +roadScreenIdx === +screenIdx && /*#__PURE__*/React.createElement(React.Fragment, null, sortPointIoiIds.length > 0 ? sortPointIoiIds.map(function (v, ind) {
        var lineDom = ind !== length - 1 && _this2.getPopoverDom(v, v.x, v.y, sortPointIoiIds[ind + 1].x, sortPointIoiIds[ind + 1].y, widths, v.stroke, v.type || 'middle', ind, v.paragraph, parentIndex);

        return lineDom;
      }) : null, sortPointIoiIds.map(function (item, index) {
        return /*#__PURE__*/React.createElement(Tooltip, {
          placement: "topLeft",
          title: !item.ioiId && !item.interId && '右键删除',
          key: "".concat(item.x, "-").concat(item.y, "-").concat(index)
        }, /*#__PURE__*/React.createElement("circle", {
          key: Math.random(),
          cx: item.x,
          cy: item.y,
          className: "circle-dom",
          "data-draggable": true,
          "data-cx": item.x,
          "data-cy": item.y,
          "data-ioiid": item.ioiId || item.interId,
          "data-index": index,
          "data-parentindex": parentIndex,
          r: widths,
          fill: "white",
          strokeWidth: 3,
          stroke: "#666",
          "data-type": item.type || 'middle'
        }));
      }));
    };

    _this2.getPopoverDom = function (data, x1, y1, x2, y2, width, stroke, type, index, paragraph, parentIndex) {
      // let newParagraph = this.getParagraph(data.ioiId||data.interId, sortPointIoiIds)
      return /*#__PURE__*/React.createElement(Popover, {
        trigger: "click",
        overlayClassName: "color-pop",
        content: _this2.chooseColor(data, type, paragraph, parentIndex),
        key: "".concat(index)
      }, /*#__PURE__*/React.createElement(Tooltip, {
        placement: "topLeft",
        title: "\u53F3\u51FB\u53EF\u6DFB\u52A0\u5206\u5272\u70B9"
      }, /*#__PURE__*/React.createElement("line", {
        className: "draw-line",
        x1: x1,
        y1: y1,
        x2: x2,
        y2: y2,
        "data-index": index,
        "data-ioiids": paragraph,
        // data-parentindex={parentIndex}
        strokeWidth: width,
        stroke: stroke,
        onContextMenu: function onContextMenu(e) {
          _this2.refreshRoad(e, parentIndex);
        }
      })));
    };

    _this2.handleCircleMouseMove = function () {
      var c = document.querySelectorAll('.circle-dom');

      var _this = _assertThisInitialized(_this2);

      c.length > 0 && Array.from(c).forEach(function (ele, index) {
        var dragItem = new PlainDraggable(ele);
        dragItem.handle.removeAttribute('transform');
        var cx = 0;
        var cy = 0;
        var parentIndex = 0;
        var ioiId = null;
        ele.addEventListener('contextmenu', function (ev) {
          ev.stopPropagation();
          ev.preventDefault();

          _this.deleteCircle(ele);
        });

        dragItem.onDragStart = function () {
          cx = dragItem.element.dataset.cx;
          parentIndex = dragItem.element.attributes['data-parentindex'].nodeValue; // ioiId = dragItem.element.attributes['data-ioiid'].nodeValue
        };

        dragItem.onDragEnd = function (newPosition) {
          var _this$refreshCirclePo = _this.refreshCirclePosition(newPosition),
              x = _this$refreshCirclePo.x,
              y = _this$refreshCirclePo.y;

          var translates = dragItem.handle.removeAttribute('transform'); // const translateAll = self.getTranslateAll(translates)

          _this.changeState(dragItem.element.dataset.type, x, y, cx, parentIndex);
        };
      });
    };

    _this2.changeState = function (type, x, y, cx, parentIndex) {
      var drawData = _this2.state.drawData;
      var onDataChange = _this2.props.onDataChange;
      var drawItem = drawData[parentIndex]; // drawData.some(item => {

      if (drawItem.type === 'road') {
        if (type !== 'middle') {
          type === 'start' ? drawItem.startIoiId.x = x : drawItem.endIoiId.x = x, type === 'start' ? drawItem.startIoiId.y = y : drawItem.endIoiId.y = y;
        } else {
          drawItem.pointIoiIds.some(function (pointItem) {
            if (pointItem.x == cx) {
              pointItem.x = x;
              pointItem.y = y;
              return true;
            }
          });
        }
      }

      onDataChange && onDataChange(drawData);
    };

    _this2.refreshCirclePosition = function (newPosition) {
      var left = newPosition.left,
          top = newPosition.top;
      var scale = _this2.props.scale;
      var contentWidth = document.getElementsByClassName('screen-save-svg')[0].clientWidth;
      var contentHeight = document.getElementsByClassName('screen-save-svg')[0].clientHeight;
      var _this2$props2 = _this2.props,
          width = _this2$props2.width,
          height = _this2$props2.height;
      var x, y;

      if (scale !== 1) {
        x = left * scale - (contentWidth * scale - parseInt(width + '')) / 2;
        y = top * scale - (contentHeight * scale - parseInt(height + '')) / 2;
      } else {
        x = left - (contentWidth - parseInt(width + '')) / 2;
        y = top - (contentHeight - parseInt(height + '')) / 2;
      }

      return {
        x: x,
        y: y
      };
    };

    _this2.handleSaveSvgHorizontalLeft = function () {
      if (!_this2.dragInsList.length) return;

      var matrixObj = _this2.getDragDataMatrix();

      var skewY = matrixObj.skewY,
          scaleX = matrixObj.scaleX;

      var drawDataItem = _this2.getDragData();

      var width = drawDataItem.width,
          height = drawDataItem.height;
      var angle = Math.round(Math.atan2(skewY, scaleX) * (180 / Math.PI));
      var radian = angle * (2 * Math.PI / 360);
      matrixObj.translateX = 0;
      var matrixArr = parseMatrixToArray(matrixObj);
      var matrixStr = "matrix(".concat(matrixArr.join(','), ")");
      drawDataItem.transform = matrixStr;

      _this2.resetDrawData();
    };

    _this2.handleSaveSvgHorizontalCenter = function () {
      if (!_this2.dragInsList.length) return;

      var matrixObj = _this2.getDragDataMatrix();

      var drawDataItem = _this2.getDragData();

      var element = _this2.dragInsList[0].el;

      var _element$getBoundingC = element.getBoundingClientRect(),
          width = _element$getBoundingC.width,
          height = _element$getBoundingC.height;

      var screenWidth = _this2.props.width;
      var scaleX = matrixObj.scaleX;
      matrixObj.translateX = (Number(screenWidth) - width) / 2;
      var matrixArr = parseMatrixToArray(matrixObj);
      var matrixStr = "matrix(".concat(matrixArr.join(','), ")");
      drawDataItem.transform = matrixStr;

      _this2.resetDrawData();
    };

    _this2.handleSaveSvgHorizontalRight = function () {
      if (!_this2.dragInsList.length) return; //  1. 获取matrix对象

      var matrixObj = _this2.getDragDataMatrix(); // 2. 获取操作对象


      var drawDataItem = _this2.getDragData(); // 3. 获取元素宽度，屏幕宽度


      var element = _this2.dragInsList[0].el;

      var _element$getBoundingC2 = element.getBoundingClientRect(),
          width = _element$getBoundingC2.width,
          height = _element$getBoundingC2.height;

      var screenWidth = _this2.props.width; // 4. 计算位移距离

      matrixObj.translateX = Number(screenWidth) - width; // matrixObj.scaleY += 1
      // 5. 转为matrix(1,2,3,2,1,1) 字符串

      var matrixArr = parseMatrixToArray(matrixObj);
      var matrixStr = "matrix(".concat(matrixArr.join(','), ")");
      drawDataItem.transform = matrixStr; // 6. 重置数据

      _this2.resetDrawData();
    };

    _this2.handleSaveSvgVerticalTop = function () {
      if (!_this2.dragInsList.length) return; //  1. 获取matrix对象

      var matrixObj = _this2.getDragDataMatrix(); // 2. 获取操作对象


      var drawDataItem = _this2.getDragData(); // 3. 获取元素宽度，屏幕宽度
      // 4. 计算位移距离


      matrixObj.translateY = 0; // 5. 转为matrix(1,2,3,2,1,1) 字符串

      var matrixArr = parseMatrixToArray(matrixObj);
      var matrixStr = "matrix(".concat(matrixArr.join(','), ")");
      drawDataItem.transform = matrixStr; // 6. 重置数据

      _this2.resetDrawData();
    };

    _this2.handleSaveSvgVerticalMiddle = function () {
      if (!_this2.dragInsList.length) return;

      var matrixObj = _this2.getDragDataMatrix();

      var drawDataItem = _this2.getDragData();

      var element = _this2.dragInsList[0].el;

      var _element$getBoundingC3 = element.getBoundingClientRect(),
          height = _element$getBoundingC3.height;

      var screenHeight = _this2.props.height;
      var scaleY = matrixObj.scaleY;
      matrixObj.translateY = (Number(screenHeight) - height) / 2;
      var matrixArr = parseMatrixToArray(matrixObj);
      var matrixStr = "matrix(".concat(matrixArr.join(','), ")");
      drawDataItem.transform = matrixStr;

      _this2.resetDrawData();
    };

    _this2.handleSaveSvgVerticalbottom = function () {
      if (!_this2.dragInsList.length) return;

      var matrixObj = _this2.getDragDataMatrix();

      var drawDataItem = _this2.getDragData();

      var element = _this2.dragInsList[0].el;

      var _element$getBoundingC4 = element.getBoundingClientRect(),
          height = _element$getBoundingC4.height;

      var screenHeight = _this2.props.height;
      var scaleY = matrixObj.scaleY;
      matrixObj.translateY = Number(screenHeight) - height;
      var matrixArr = parseMatrixToArray(matrixObj);
      var matrixStr = "matrix(".concat(matrixArr.join(','), ")");
      drawDataItem.transform = matrixStr;

      _this2.resetDrawData();
    };

    _this2.handleSaveSvgScale = function (number) {
      if (typeof number !== 'number' || isNaN(number)) return console.error('handleSaveSvgScale function params must be number');
      if (!_this2.dragInsList.length) return;

      var matrixObj = _this2.getDragDataMatrix();

      var drawDataItem = _this2.getDragData();

      var scaleX = matrixObj.scaleX;
      var scaleY = matrixObj.scaleY;
      matrixObj.scaleX = scaleX + number;
      matrixObj.scaleY = scaleY + number;
      var matrixArr = parseMatrixToArray(matrixObj);
      var matrixStr = "matrix(".concat(matrixArr.join(','), ")");
      drawDataItem.transform = matrixStr;

      _this2.resetDrawData();
    };

    _this2.handleSaveSvgDelete = function () {
      if (!_this2.dragInsList.length) return;
      var element = _this2.dragInsList[0].el;

      var dragInstanc = _this2.dragInsList.pop();

      var drawDataIndex = element.getAttribute('data-parentindex');

      _this2.state.drawData.splice(drawDataIndex, 1);

      dragInstanc.disable();

      _this2.setState({
        drawData: _toConsumableArray(_this2.state.drawData)
      }, function () {
        _this2.props.onDataChange && _this2.props.onDataChange(_this2.state.drawData);
      });
    };

    _this2.getDragDataMatrix = function () {
      if (!_this2.dragInsList.length) return;
      window.dragInstance = _this2.dragInsList[0] || {};

      var drawDataItem = _this2.getDragData();

      var matrix = drawDataItem.transform;
      var matrixObj = {};

      if (!matrix.includes('matrix')) {
        matrixObj = {
          scaleX: 1,
          skewY: 0,
          skewX: 0,
          scaleY: 1,
          translateX: 0,
          translateY: 0
        };
      } else {
        matrixObj = parseMatrixToObject(matrix);
      }

      return matrixObj;
    };

    _this2.getDragData = function () {
      var element = _this2.dragInsList[0].el;
      var drawDataIndex = element.getAttribute('data-parentindex');
      var drawDataItem = _this2.state.drawData[drawDataIndex];
      return drawDataItem;
    };

    _this2.resetDrawData = function () {
      var dragInstanc = _this2.dragInsList[0];
      var element = dragInstanc.el;
      var type = element.getAttribute('data-type');

      var options = _this2.getOptions(type);

      _this2.setState({
        drawData: _toConsumableArray(_this2.state.drawData)
      }, function () {
        dragInstanc.disable();
        dragInstanc.enable(options);
        _this2.props.onDataChange && _this2.props.onDataChange(_this2.state.drawData);
      });
    };

    _this2.tabChange = function (e) {
      var index = e.currentTarget.dataset.index;
      var onScreenIndexChange = _this2.props.onScreenIndexChange;
      onScreenIndexChange && onScreenIndexChange(index);
    };

    _this2.reCalcTranslateXY = function (matrixObj, containerWidth, containerHeight, width, height) {
      var translateX = matrixObj.translateX,
          translateY = matrixObj.translateY;
      var outerWidth = translateX + width;
      var outerHeight = translateY + height;

      if (translateX < 0) {
        matrixObj.translateX = 0;
      } else if (outerWidth > containerWidth) {
        matrixObj.translateX = containerWidth - width;
      }

      if (translateY < 0) {
        matrixObj.translateY = 0;
      } else if (outerHeight > containerHeight) {
        matrixObj.translateY = containerHeight - height;
      }

      return _objectSpread({}, matrixObj);
    };

    _this2.svgRef = /*#__PURE__*/React.createRef();
    _this2.dragInsList = [];
    _this2.state = {
      drawData: [],
      newPointIoiIds: []
    };
    return _this2;
  }

  _createClass(SvgEditor, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var onChangeScale = this.props.onChangeScale;
      var drawData = this.addParagraph(JSON.parse(JSON.stringify(this.props.data)));
      this.initDrawData(drawData);
      this.addEvent();
      onChangeScale && onChangeScale();
    }
  }, {
    key: "componentWillReceiveProps",
    value: function componentWillReceiveProps(nextProps) {
      if (!isEqual(nextProps.data, this.props.data)) {
        // let nextPropsData = this.addParagraph(nextProps.data)
        this.initDrawData(nextProps.data);
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.clearEvent();
    } // componentDidUpdate () {
    //   this.handleCircleMouseMove()
    // }

  }, {
    key: "clearEvent",
    value: function clearEvent() {
      document.removeEventListener('click', this.addOutSideClickListener);
    }
  }, {
    key: "addEvent",
    value: function addEvent() {
      document.addEventListener('click', this.addOutSideClickListener);
    }
  }, {
    key: "initDrawData",
    value: function initDrawData(data) {
      var _this3 = this;

      // console.log('SvgEditor recieve data: ', data)
      var drawData = JSON.parse(JSON.stringify(data));
      var maxZIndex = Math.max.apply(Math, _toConsumableArray(drawData.map(function (v) {
        return v.zIndex;
      }))); // is not  a number

      maxZIndex = maxZIndex >= 0 ? maxZIndex : 0;
      drawData.forEach(function (v, i) {
        if (!isNumber(v.zIndex)) {
          v.zIndex = maxZIndex + i;
        }
      });
      drawData.sort(function (a, b) {
        return a.zIndex - b.zIndex;
      });
      this.setState({
        drawData: drawData
      }, function () {
        _this3.initEvent(); // 更新数据同步给予拖拽拉伸、缩放功能


        _this3.handleCircleMouseMove();
      });
    }
  }, {
    key: "initEvent",
    value: function initEvent() {
      var _this4 = this;

      var dragList = document.querySelectorAll('.drag-ele');
      Array.from(dragList).forEach(function (ele, index) {
        var hasEvent = ele.getAttribute('data-event');
        var type = ele.getAttribute('data-type');

        if (!hasEvent) {
          ele.setAttribute('data-event', 'true');
          var instance; // subjx实例对象

          var isClick = true; // 增加状态以避免拖拽时触发点击事件

          var handleMouseMove = function handleMouseMove() {
            isClick = false;
          };

          ele.addEventListener('mousedown', function (e) {
            if (e.button === 0) {
              ele.addEventListener('mousemove', handleMouseMove);
            }
          });
          ele.addEventListener('mouseup', function (e) {
            // 判断鼠标左键点击 e.button: 0 鼠标左键点击
            if (e.button === 0) {
              ele.removeEventListener('mousemove', handleMouseMove);

              if (isClick) {
                if (ele.classList.contains('sjx-drag')) {
                  instance && instance.disable();
                  _this4.dragInsList = [];
                } else {
                  var _type = ele.getAttribute('data-type');

                  var detailType = ele.getAttribute('data-detail-type');

                  var options = _this4.getOptions(!_type);

                  var parentIndex = ele.getAttribute('data-parentindex');
                  instance = subjx(ele).drag(options)[0];

                  while (_this4.dragInsList.length) {
                    var _instance = _this4.dragInsList.pop();

                    _instance && _instance.disable();
                  }

                  _this4.dragInsList.push(instance);

                  var sendData = function sendData() {
                    _this4.transferData(instance, parentIndex, _type, detailType);
                  };

                  instance.on('dragEnd', function () {
                    sendData();
                  });
                  instance.on('drag', function () {
                    sendData();
                  });
                  instance.on('resizeEnd', function () {
                    sendData();
                  });
                  instance.on('rotateEnd', function () {
                    sendData();
                  });
                }
              } else {
                isClick = true;
              }
            }
          });
        }
      });
    }
  }, {
    key: "getOptions",
    value: function getOptions(type) {
      switch (type) {
        case 'text':
        case 'param':
        case 'road':
          return {
            scalable: false,
            resizable: false,
            rotatable: false
          };

        default:
          return {
            snap: {
              x: 2,
              y: 2,
              angle: 2
            }
          };
      }
    }
  }, {
    key: "transferData",
    value: function transferData(instance, index, type, detailType) {
      var _this$props = this.props,
          onDataChange = _this$props.onDataChange,
          svgWidth = _this$props.width,
          svgHeight = _this$props.height;
      if (!onDataChange) return;
      var e = instance.el;
      var transform = e.getAttribute('transform');
      var matrixObj = parseMatrixToObject(transform);
      var drawData = this.state.drawData;
      var item = drawData[index];
      var subType = item.subType;

      if (type === 'text' || type === 'param') {
        drawData[index].transform = transform;
      }

      if (type === 'images') {
        var x = e.getAttribute('x');
        var y = e.getAttribute('y');
        var width = e.getAttribute('width');
        var height = e.getAttribute('height');
        var imageElement;

        if (subType === PLACEHOLDER) {
          imageElement = e.getElementsByTagName('image')[0];
          width = imageElement.getAttribute('width');
          height = imageElement.getAttribute('height');
        }

        drawData[index].x = Number(x);
        drawData[index].y = Number(y);
        drawData[index].width = Number(width);
        drawData[index].height = Number(height);
        drawData[index].transform = transform;
      }

      if (type === 'road') {
        var x1 = e.getAttribute('x1');
        var x2 = e.getAttribute('x2');
        var y1 = e.getAttribute('y1');
        var y2 = e.getAttribute('y2');

        var _width = e.getAttribute('width');

        var stroke = e.getAttribute('stroke');
        var startIoiId = e.getAttribute('data-start');
        var endIoiId = e.getAttribute('data-end');
        var pointIoiIds = e.getAttribute('data-point');

        var _transform = e.getAttribute('transform'); // 在这里定义好传给后端的数据格式
        // 是因为Map.startToEndPoint 和 pointDistance 每次进页面是没有值的，因此不能在store 直接给getFormworkInfo 的road赋值
        // 问题：只能instanc对象发生拖拽的时候 传递端点和中间点的数据


        drawData[index].x1 = Number(x1);
        drawData[index].x2 = Number(x2);
        drawData[index].y1 = Number(y1);
        drawData[index].y1 = Number(y1);
        drawData[index].widths = Number(_width);
        drawData[index].transform = _transform;
        drawData[index].stroke = stroke;
        drawData[index].startIoiId = {
          // 端点开始
          x: x1,
          y: y1,
          ioiId: JSON.parse(startIoiId).ioiId,
          color: '#ffffff',
          lat: JSON.parse(startIoiId).lat,
          lng: JSON.parse(startIoiId).lng
        };
        drawData[index].endIoiId = {
          // 端点结束
          x: x2,
          y: y2,
          ioiId: JSON.parse(endIoiId).ioiId,
          color: '#ffffff',
          lat: JSON.parse(endIoiId).lat,
          lng: JSON.parse(endIoiId).lng
        };
        drawData[index].pointIoiIds = JSON.parse(pointIoiIds); //  中间点数组

        drawData[index].otherIoiIds = [];
      }

      if (type === 'polygons') {
        if (detailType === 'rect') {
          var _width2 = e.getAttribute('width');

          var _height = e.getAttribute('height');

          var _x = e.getAttribute('x');

          var _y = e.getAttribute('y');

          if (subType === PLACEHOLDER) {
            var rectElement = e.getElementsByTagName('rect')[1];
            _x = rectElement.getAttribute('x');
            _y = rectElement.getAttribute('y');
            _width2 = rectElement.getAttribute('width');
            _height = rectElement.getAttribute('height');
          }

          drawData[index].x = Number(_x);
          drawData[index].y = Number(_y);
          drawData[index].width = Number(_width2);
          drawData[index].height = Number(_height);
          drawData[index].transform = transform;
        }

        if (detailType === 'oval') {
          var _cx = e.getAttribute('cx');

          var cy = e.getAttribute('cy');
          var r = e.getAttribute('r');

          if (subType === PLACEHOLDER) {
            var ovalElement = e.getElementsByTagName('circle')[0];
            _cx = ovalElement.getAttribute('cx');
            cy = ovalElement.getAttribute('cy');
            r = ovalElement.getAttribute('r');
          }

          drawData[index].cx = Number(_cx);
          drawData[index].cy = Number(cy);
          drawData[index].r = Number(r);
          drawData[index].transform = transform;
        }

        if (detailType === 'polygon') {
          var points = e.getAttribute('points');

          if (subType === PLACEHOLDER) {
            var polygonElement = e.getElementsByTagName('polygon')[0];
            points = polygonElement.getAttribute('points');
          }

          drawData[index].points = points;
          drawData[index].transform = transform;
        }

        if (detailType === 'line' || detailType === 'dashedLine') {
          var rtElement = e;

          if (subType === PLACEHOLDER) {
            rtElement = e.getElementsByTagName('line')[0];
          }

          var _x2 = rtElement.getAttribute('x1');

          var _y2 = rtElement.getAttribute('y1');

          var _x3 = rtElement.getAttribute('x2');

          var _y3 = rtElement.getAttribute('y2');

          drawData[index].x1 = Number(_x2);
          drawData[index].y1 = Number(_y2);
          drawData[index].x2 = Number(_x3);
          drawData[index].y2 = Number(_y3);
          drawData[index].transform = transform;
        }

        if (subType === PLACEHOLDER) {
          var containerRectEle = e.getElementsByTagName('rect')[0];
          var textEle = e.getElementsByTagName('text')[0];
          var containerX = containerRectEle.getAttribute('x');
          var containerY = containerRectEle.getAttribute('y');
          var containerWidth = containerRectEle.getAttribute('width');
          var containerHeight = containerRectEle.getAttribute('height');
          var textX = textEle.getAttribute('x');
          var textY = textEle.getAttribute('y');
          drawData[index].textX = Number(textX);
          drawData[index].textY = Number(textY);
          drawData[index].containerX = Number(containerX);
          drawData[index].containerY = Number(containerY);
          drawData[index].containerWidth = Number(containerWidth);
          drawData[index].containerHeight = Number(containerHeight);
        }
      }

      onDataChange(drawData);
    } // 点击新增地图点

  }, {
    key: "refreshRoad",
    value: function refreshRoad(e, parentIndex) {
      var _this$props2 = this.props,
          onDataChange = _this$props2.onDataChange,
          scale = _this$props2.scale;
      e.stopPropagation();
      e.preventDefault(); // e.returnValue = false;

      var drawData = this.state.drawData;
      var cx = e.clientX;
      var cy = e.clientY;
      var contentWidth = document.getElementsByClassName('screen-save-svg')[0].clientWidth;
      var contentHeight = document.getElementsByClassName('screen-save-svg')[0].clientWidth;
      var _this$props3 = this.props,
          width = _this$props3.width,
          height = _this$props3.height; // const parentIndex = e.getAttribute('data-parentindex')

      var x, y;

      if (scale !== 1) {
        x = cx * scale - (contentWidth * scale - Number(width)) / 2;
        y = cy * scale - (contentHeight * scale - Number(height)) / 2;
      } else {
        x = cx - (contentWidth - Number(width)) / 2;
        y = cy - (contentHeight - Number(height)) / 2;
      }

      var drawDataItem = drawData[parentIndex]; // drawData[parentIndex].some(item => {

      if (drawDataItem.type === 'road') {
        var index = e.target.getAttribute('data-index');
        var paragraph = e.target.getAttribute('data-ioiids');
        var start = drawDataItem.pointIoiIds.slice(0, index);
        var end = drawDataItem.pointIoiIds.slice(index);
        drawDataItem.pointIoiIds = [].concat(_toConsumableArray(start), [{
          // ...item.pointIoiIds[0],
          x: x + '',
          y: y + '',
          ioiId: null,
          paragraph: paragraph,
          color: drawDataItem.pointIoiIds[index - 1] && drawDataItem.pointIoiIds[index - 1].color,
          stroke: +index === 0 ? drawDataItem.stroke : drawDataItem.pointIoiIds[index - 1].stroke
        }], _toConsumableArray(end));
      }

      onDataChange && onDataChange(drawData);
    } // 删除点

  }, {
    key: "renderDrawData",
    value: function renderDrawData(screenIdx) {
      var _this5 = this;

      var drawData = this.state.drawData;
      return drawData.map(function (item, index) {
        var type = item.type,
            detailType = item.detailType;

        if (type === 'road') {
          return /*#__PURE__*/React.createElement(React.Fragment, {
            key: item.key
          }, _this5.getDrawData(type, detailType, item, index, screenIdx));
        } else {
          var menu = /*#__PURE__*/React.createElement(Menu, null, /*#__PURE__*/React.createElement(Menu.Item, {
            key: "toTop",
            onClick: function onClick() {
              return _this5.handleMenuToTop(item, index);
            }
          }, "\u7F6E\u9876"), /*#__PURE__*/React.createElement(Menu.Item, {
            key: "delete",
            onClick: function onClick() {
              return _this5.handleMenuDelete(item, index);
            }
          }, "\u5220\u9664"));
          return (
            /*#__PURE__*/
            // @ts-ignore
            React.createElement(Dropdown, {
              key: index,
              overlay: menu,
              trigger: ['contextMenu']
            }, /*#__PURE__*/React.createElement("g", null, _this5.getDrawData(type, detailType, item, index, screenIdx)))
          );
        }
      });
    }
  }, {
    key: "getDrawData",
    value: function getDrawData(type, detailType, item, index, screenIdx) {
      if (type === 'road') return this.renderRoad(item, index, screenIdx);
      if (type === 'text') return this.renderText(item, index, screenIdx);
      if (type === 'param') return this.renderParam(item, index, screenIdx);
      if (type === 'images') return this.renderImage(item, index, screenIdx);

      if (type === 'polygons') {
        if (detailType === 'rect') return this.renderRect(item, index, screenIdx);
        if (detailType === 'oval') return this.renderOval(item, index, screenIdx);
        if (detailType === 'polygon') return this.renderPolygon(item, index, screenIdx);
        if (detailType === 'line') return this.renderLine(item, index, screenIdx);
        if (detailType === 'dashedLine') return this.renderDashedLine(item, index, screenIdx);
      }
    }
  }, {
    key: "renderText",
    value: function renderText(item, index, screenIdx) {
      var _Object$assign2 = Object.assign({}, textConfig, item),
          type = _Object$assign2.type,
          text = _Object$assign2.text,
          x = _Object$assign2.x,
          y = _Object$assign2.y,
          fill = _Object$assign2.fill,
          fontSize = _Object$assign2.fontSize,
          writingMode = _Object$assign2.writingMode,
          transform = _Object$assign2.transform,
          textScreenIdx = _Object$assign2.screenIdx,
          subType = _Object$assign2.subType,
          placeholderIndex = _Object$assign2.placeholderIndex;

      var dominantBaseline = writingMode === 'lr' ? 'text-before-edge' : 'text-after-edge';

      if (subType && subType === PLACEHOLDER) {
        var width = writingMode === 'lr' ? text.length * (+fontSize - 2) : +fontSize + 10;
        var height = writingMode === 'lr' ? +fontSize + 10 : text.length * (+fontSize - 2);
        return +textScreenIdx === +screenIdx && /*#__PURE__*/React.createElement("g", {
          className: "drag-ele",
          "data-parentindex": index,
          transform: transform,
          x: x,
          y: y,
          "data-type": type
        }, /*#__PURE__*/React.createElement("rect", {
          strokeWidth: "2",
          strokeDasharray: "6 3",
          stroke: "#666",
          fillOpacity: "0",
          width: width,
          height: height
        }), /*#__PURE__*/React.createElement("text", {
          x: "0",
          y: "0",
          textLength: 0,
          stroke: "#666",
          color: "#666",
          fontSize: 14,
          transform: "matrix(1,0,0,1,0,12)"
        }, placeholderIndex), /*#__PURE__*/React.createElement("text", {
          key: index,
          fill: fill,
          fontSize: fontSize,
          writingMode: writingMode,
          transform: "matrix(1,0,0,1,5,5)",
          dominantBaseline: dominantBaseline,
          "data-type": type
        }, text));
      } else {
        return +textScreenIdx === +screenIdx && /*#__PURE__*/React.createElement("text", {
          x: x,
          y: y,
          key: index,
          fill: fill,
          fontSize: fontSize,
          className: "drag-ele",
          "data-parentindex": index,
          writingMode: writingMode,
          transform: transform || '',
          dominantBaseline: dominantBaseline,
          "data-type": type
        }, text);
      }
    }
  }, {
    key: "renderParam",
    value: function renderParam(item, index, screenIdx) {
      var _Object$assign3 = Object.assign({}, paramConfig, item),
          type = _Object$assign3.type,
          text = _Object$assign3.text,
          params = _Object$assign3.params,
          x = _Object$assign3.x,
          y = _Object$assign3.y,
          fill = _Object$assign3.fill,
          fontSize = _Object$assign3.fontSize,
          writingMode = _Object$assign3.writingMode,
          transform = _Object$assign3.transform,
          paramsScreenIdx = _Object$assign3.screenIdx,
          subType = _Object$assign3.subType,
          placeholderIndex = _Object$assign3.placeholderIndex;

      var dominantBaseline = writingMode === 'lr' ? 'text-before-edge' : 'text-after-edge';
      var _params$ = params[0],
          paramKey = _params$.key,
          paramValue = _params$.value;
      var paramText = text.replace('${' + paramKey + '}', paramValue);
      if (+paramsScreenIdx !== +screenIdx) return;

      if (subType && subType === PLACEHOLDER) {
        var width = writingMode === 'lr' ? paramText.length * (+fontSize - 2) : +fontSize + 10;
        var height = writingMode === 'lr' ? +fontSize + 10 : paramText.length * (+fontSize - 2);
        return /*#__PURE__*/React.createElement("g", {
          className: "drag-ele",
          key: index,
          transform: transform,
          x: x,
          y: y,
          "data-type": type,
          "data-parentindex": index
        }, /*#__PURE__*/React.createElement("rect", {
          strokeWidth: "2",
          strokeDasharray: "6 3",
          stroke: "#666",
          fillOpacity: "0",
          width: width + 10,
          height: height + 10
        }), /*#__PURE__*/React.createElement("text", {
          x: "0",
          y: "0",
          textLength: 0,
          stroke: "#666",
          color: "#666",
          fontSize: 14,
          transform: "matrix(1,0,0,1,0,12)"
        }, placeholderIndex), /*#__PURE__*/React.createElement("text", {
          fill: fill,
          fontSize: fontSize,
          writingMode: writingMode,
          transform: "matrix(1,0,0,1,5,5)",
          dominantBaseline: dominantBaseline
        }, paramText));
      } else {
        return /*#__PURE__*/React.createElement("text", {
          x: x,
          y: y,
          key: index,
          fill: fill,
          fontSize: fontSize,
          className: "drag-ele",
          writingMode: writingMode,
          "data-parentindex": index,
          transform: transform || '',
          dominantBaseline: dominantBaseline,
          "data-type": type
        }, paramText);
      }
    }
  }, {
    key: "renderImage",
    value: function renderImage(item, index, screenIdx) {
      var _Object$assign4 = Object.assign({}, imageConfig, item),
          type = _Object$assign4.type,
          x = _Object$assign4.x,
          y = _Object$assign4.y,
          width = _Object$assign4.width,
          height = _Object$assign4.height,
          transform = _Object$assign4.transform,
          base64Str = _Object$assign4.base64Str,
          url = _Object$assign4.url,
          imgScreenIdx = _Object$assign4.screenIdx,
          subType = _Object$assign4.subType,
          placeholderIndex = _Object$assign4.placeholderIndex;

      if (+imgScreenIdx !== +screenIdx) return;

      if (subType && subType === PLACEHOLDER) {
        return /*#__PURE__*/React.createElement("g", {
          className: "drag-ele",
          transform: transform,
          x: x,
          y: y,
          "data-type": type,
          "data-parentindex": index
        }, /*#__PURE__*/React.createElement("rect", {
          strokeWidth: "2",
          strokeDasharray: "6 3",
          stroke: "#666",
          fillOpacity: "0",
          width: width,
          height: height
        }), /*#__PURE__*/React.createElement("text", {
          x: "5",
          y: "12",
          textLength: 0,
          stroke: "#666",
          color: "#666",
          fontSize: 14
        }, placeholderIndex), /*#__PURE__*/React.createElement("image", {
          key: index,
          width: width,
          height: height,
          href: base64Str || url
        }));
      } else {
        return /*#__PURE__*/React.createElement("image", {
          key: index,
          transform: transform,
          className: "drag-ele",
          "data-type": type,
          x: x,
          y: y,
          "data-parentindex": index,
          width: width,
          height: height,
          href: base64Str || url
        });
      }
    }
  }, {
    key: "renderRect",
    value: function renderRect(item, index, screenIdx) {
      var _Object$assign5 = Object.assign({}, rectConfig, item),
          type = _Object$assign5.type,
          detailType = _Object$assign5.detailType,
          x = _Object$assign5.x,
          y = _Object$assign5.y,
          width = _Object$assign5.width,
          height = _Object$assign5.height,
          containerWidth = _Object$assign5.containerWidth,
          containerHeight = _Object$assign5.containerHeight,
          containerX = _Object$assign5.containerX,
          containerY = _Object$assign5.containerY,
          tx = _Object$assign5.textX,
          ty = _Object$assign5.textY,
          fill = _Object$assign5.fill,
          radius = _Object$assign5.radius,
          transform = _Object$assign5.transform,
          rectScreenIdx = _Object$assign5.screenIdx,
          subType = _Object$assign5.subType,
          placeholderIndex = _Object$assign5.placeholderIndex;

      var cWidth = containerWidth !== undefined ? containerWidth : width + 20;
      var cHeight = containerHeight !== undefined ? containerHeight : height + 20;
      var cX = containerX !== undefined ? containerX : 0;
      var cY = containerY !== undefined ? containerY : 0;
      var textX = tx !== undefined ? tx : 0;
      var textY = ty !== undefined ? ty : 20;
      if (+rectScreenIdx !== +screenIdx) return;

      if (subType && subType === PLACEHOLDER) {
        return /*#__PURE__*/React.createElement("g", {
          className: "drag-ele",
          "data-parentindex": index,
          transform: transform,
          "data-type": type,
          "data-detail-type": detailType
        }, /*#__PURE__*/React.createElement("rect", {
          strokeWidth: "2",
          strokeDasharray: "6 3",
          stroke: "#666",
          fillOpacity: "0",
          width: cWidth,
          height: cHeight,
          x: cX,
          y: cY
        }), /*#__PURE__*/React.createElement("rect", {
          key: index,
          rx: radius,
          ry: radius,
          x: x,
          y: y,
          width: width,
          height: height,
          "data-parentindex": index,
          fill: fill,
          "data-type": type,
          "data-detail-type": detailType
        }), /*#__PURE__*/React.createElement("text", {
          x: textX,
          y: textY,
          textLength: 0,
          stroke: "#666",
          color: "#666",
          fontSize: 14
        }, placeholderIndex));
      } else {
        return /*#__PURE__*/React.createElement("rect", {
          key: index,
          x: x,
          y: y,
          rx: radius,
          ry: radius,
          width: width,
          height: height,
          "data-parentindex": index,
          fill: fill,
          transform: transform,
          className: "drag-ele",
          "data-type": type,
          "data-detail-type": detailType
        });
      }
    } // 渲染多边形-圆形

  }, {
    key: "renderOval",
    value: function renderOval(item, index, screenIdx) {
      var _Object$assign6 = Object.assign({}, ovalConfig, item),
          type = _Object$assign6.type,
          detailType = _Object$assign6.detailType,
          cx = _Object$assign6.cx,
          cy = _Object$assign6.cy,
          r = _Object$assign6.r,
          fill = _Object$assign6.fill,
          containerWidth = _Object$assign6.containerWidth,
          containerHeight = _Object$assign6.containerHeight,
          containerX = _Object$assign6.containerX,
          containerY = _Object$assign6.containerY,
          tx = _Object$assign6.textX,
          ty = _Object$assign6.textY,
          transform = _Object$assign6.transform,
          ovalScreenIdx = _Object$assign6.screenIdx,
          subType = _Object$assign6.subType,
          placeholderIndex = _Object$assign6.placeholderIndex;

      var cWidth = containerWidth !== undefined ? containerWidth : r * 2 + 20;
      var cHeight = containerHeight !== undefined ? containerHeight : r * 2 + 20;
      var cX = containerX !== undefined ? containerX : 0;
      var cY = containerY !== undefined ? containerY : 0;
      var textX = tx !== undefined ? tx : 0;
      var textY = ty !== undefined ? ty : 20;
      if (+ovalScreenIdx !== +screenIdx) return;

      if (subType && subType === PLACEHOLDER) {
        var width = r * 2;
        var height = width;
        return /*#__PURE__*/React.createElement("g", {
          className: "drag-ele",
          transform: transform,
          "data-type": type,
          "data-detail-type": detailType,
          "data-parentindex": index
        }, /*#__PURE__*/React.createElement("rect", {
          strokeWidth: "2",
          strokeDasharray: "6 3",
          stroke: "#666",
          fillOpacity: "0",
          width: cWidth,
          height: cHeight,
          x: cX,
          y: cY
        }), /*#__PURE__*/React.createElement("circle", {
          key: index,
          transform: "matrix(1,0,0,1,10,10)",
          cx: cx,
          cy: cy,
          r: r,
          fill: fill
        }), /*#__PURE__*/React.createElement("text", {
          x: textX,
          y: textY,
          textLength: 0,
          stroke: "#666",
          color: "#666",
          fontSize: 14
        }, placeholderIndex));
      } else {
        return /*#__PURE__*/React.createElement("circle", {
          key: index,
          transform: transform,
          className: "drag-ele",
          "data-type": type,
          "data-detail-type": detailType,
          "data-parentindex": index,
          cx: cx,
          cy: cy,
          r: r,
          fill: fill
        });
      }
    } // 渲染多边形-三角形

  }, {
    key: "renderPolygon",
    value: function renderPolygon(item, index, screenIdx) {
      var _Object$assign7 = Object.assign({}, polygonConfig, item),
          type = _Object$assign7.type,
          detailType = _Object$assign7.detailType,
          points = _Object$assign7.points,
          fill = _Object$assign7.fill,
          containerWidth = _Object$assign7.containerWidth,
          containerHeight = _Object$assign7.containerHeight,
          containerX = _Object$assign7.containerX,
          containerY = _Object$assign7.containerY,
          tx = _Object$assign7.textX,
          ty = _Object$assign7.textY,
          transform = _Object$assign7.transform,
          polygonScreenIdx = _Object$assign7.screenIdx,
          subType = _Object$assign7.subType,
          placeholderIndex = _Object$assign7.placeholderIndex;

      if (+polygonScreenIdx !== +screenIdx) return;

      if (subType && subType === PLACEHOLDER) {
        var _calcPolygonWidthHeig = calcPolygonWidthHeight(points),
            _calcPolygonWidthHeig2 = _slicedToArray(_calcPolygonWidthHeig, 2),
            width = _calcPolygonWidthHeig2[0],
            height = _calcPolygonWidthHeig2[1];

        var cWidth = containerWidth !== undefined ? containerWidth : width + 20;
        var cHeight = containerHeight !== undefined ? containerHeight : height + 20;
        var cX = containerX !== undefined ? containerX : 0;
        var cY = containerY !== undefined ? containerY : 0;
        var textX = tx !== undefined ? tx : 0;
        var textY = ty !== undefined ? ty : 20;
        return /*#__PURE__*/React.createElement("g", {
          className: "drag-ele",
          transform: transform,
          "data-type": type,
          "data-detail-type": detailType,
          "data-parentindex": index,
          key: index
        }, /*#__PURE__*/React.createElement("rect", {
          strokeWidth: "2",
          strokeDasharray: "6 3",
          stroke: "#666",
          fillOpacity: "0",
          width: cWidth,
          height: cHeight,
          x: cX,
          y: cY
        }), /*#__PURE__*/React.createElement("polygon", {
          key: index,
          points: points,
          fill: fill
        }), /*#__PURE__*/React.createElement("text", {
          x: textX,
          y: textY,
          textLength: 0,
          stroke: "#666",
          color: "#666",
          fontSize: 14
        }, placeholderIndex));
      } else {
        return /*#__PURE__*/React.createElement("polygon", {
          key: index,
          transform: transform,
          className: "drag-ele",
          "data-type": type,
          "data-detail-type": detailType,
          "data-parentindex": index,
          points: points,
          fill: fill
        });
      }
    }
  }, {
    key: "renderLine",
    value: function renderLine(item, index, screenIdx) {
      var _Object$assign8 = Object.assign({}, lineConfig, item),
          type = _Object$assign8.type,
          detailType = _Object$assign8.detailType,
          containerWidth = _Object$assign8.containerWidth,
          containerHeight = _Object$assign8.containerHeight,
          containerX = _Object$assign8.containerX,
          containerY = _Object$assign8.containerY,
          tx = _Object$assign8.textX,
          ty = _Object$assign8.textY,
          transform = _Object$assign8.transform,
          x1 = _Object$assign8.x1,
          x2 = _Object$assign8.x2,
          y1 = _Object$assign8.y1,
          y2 = _Object$assign8.y2,
          stroke = _Object$assign8.stroke,
          strokeWidth = _Object$assign8.strokeWidth,
          lineScreenIdx = _Object$assign8.screenIdx,
          subType = _Object$assign8.subType,
          placeholderIndex = _Object$assign8.placeholderIndex;

      if (+lineScreenIdx !== +screenIdx) return;

      if (subType && subType === PLACEHOLDER) {
        var _calcPolygonWidthHeig3 = calcPolygonWidthHeight("".concat(x1, ",").concat(y1, " ").concat(x2, ",").concat(y2)),
            _calcPolygonWidthHeig4 = _slicedToArray(_calcPolygonWidthHeig3, 2),
            width = _calcPolygonWidthHeig4[0],
            height = _calcPolygonWidthHeig4[1];

        var cWidth = containerWidth !== undefined ? containerWidth : width + 20;
        var cHeight = containerHeight !== undefined ? containerHeight : height + 20;
        var cX = containerX !== undefined ? containerX : 0;
        var cY = containerY !== undefined ? containerY : 0;
        var textX = tx !== undefined ? tx : 0;
        var textY = ty !== undefined ? ty : 20;
        return /*#__PURE__*/React.createElement("g", {
          key: index,
          className: "drag-ele",
          "data-parentindex": index,
          transform: transform,
          "data-type": type,
          "data-detail-type": detailType
        }, /*#__PURE__*/React.createElement("rect", {
          strokeWidth: "2",
          strokeDasharray: "6 3",
          stroke: "#666",
          fillOpacity: "0",
          width: cWidth,
          height: cHeight,
          x: cX,
          y: cY
        }), /*#__PURE__*/React.createElement("line", {
          x1: x1,
          x2: x2,
          y1: y1,
          y2: y2,
          stroke: stroke,
          strokeWidth: strokeWidth
        }), /*#__PURE__*/React.createElement("text", {
          x: textX,
          y: textY,
          textLength: 0,
          stroke: "#666",
          color: "#666",
          fontSize: 14
        }, placeholderIndex));
      } else {
        return /*#__PURE__*/React.createElement("line", {
          key: index,
          transform: transform,
          className: "drag-ele",
          "data-type": type,
          "data-detail-type": detailType,
          "data-parentindex": index,
          x1: x1,
          x2: x2,
          y1: y1,
          y2: y2,
          stroke: stroke,
          strokeWidth: strokeWidth
        });
      }
    }
  }, {
    key: "renderDashedLine",
    value: function renderDashedLine(item, index, screenIdx) {
      var _Object$assign9 = Object.assign({}, dashedLineConfig, item),
          type = _Object$assign9.type,
          detailType = _Object$assign9.detailType,
          containerWidth = _Object$assign9.containerWidth,
          containerHeight = _Object$assign9.containerHeight,
          containerX = _Object$assign9.containerX,
          containerY = _Object$assign9.containerY,
          tx = _Object$assign9.textX,
          ty = _Object$assign9.textY,
          transform = _Object$assign9.transform,
          x1 = _Object$assign9.x1,
          x2 = _Object$assign9.x2,
          y1 = _Object$assign9.y1,
          y2 = _Object$assign9.y2,
          stroke = _Object$assign9.stroke,
          strokeWidth = _Object$assign9.strokeWidth,
          strokeDasharray = _Object$assign9.strokeDasharray,
          dashedLineScreenIdx = _Object$assign9.screenIdx,
          subType = _Object$assign9.subType,
          placeholderIndex = _Object$assign9.placeholderIndex;

      if (+dashedLineScreenIdx !== +screenIdx) return;

      if (subType && subType === PLACEHOLDER) {
        var _calcPolygonWidthHeig5 = calcPolygonWidthHeight("".concat(x1, ",").concat(y1, " ").concat(x2, ",").concat(y2)),
            _calcPolygonWidthHeig6 = _slicedToArray(_calcPolygonWidthHeig5, 2),
            width = _calcPolygonWidthHeig6[0],
            height = _calcPolygonWidthHeig6[1];

        var cWidth = containerWidth !== undefined ? containerWidth : width + 20;
        var cHeight = containerHeight !== undefined ? containerHeight : height + 20;
        var cX = containerX !== undefined ? containerX : 0;
        var cY = containerY !== undefined ? containerY : 0;
        var textX = tx !== undefined ? tx : 0;
        var textY = ty !== undefined ? ty : 20;
        return /*#__PURE__*/React.createElement("g", {
          key: index,
          className: "drag-ele",
          "data-parentindex": index,
          transform: transform,
          "data-type": type,
          "data-detail-type": detailType
        }, /*#__PURE__*/React.createElement("rect", {
          strokeWidth: "2",
          strokeDasharray: "6 3",
          stroke: "#666",
          fillOpacity: "0",
          width: cWidth,
          height: cHeight,
          x: cX,
          y: cY
        }), /*#__PURE__*/React.createElement("line", {
          x1: x1,
          x2: x2,
          y1: y1,
          y2: y2,
          stroke: stroke,
          strokeWidth: strokeWidth,
          strokeDasharray: strokeDasharray
        }), /*#__PURE__*/React.createElement("text", {
          x: textX,
          y: textY,
          textLength: 0,
          stroke: "#666",
          color: "#666",
          fontSize: 14
        }, placeholderIndex));
      } else {
        return /*#__PURE__*/React.createElement("line", {
          key: index,
          transform: transform,
          className: "drag-ele",
          "data-type": type,
          "data-detail-type": detailType,
          "data-parentindex": index,
          x1: x1,
          x2: x2,
          y1: y1,
          y2: y2,
          stroke: stroke,
          strokeWidth: strokeWidth,
          strokeDasharray: strokeDasharray
        });
      }
    }
  }, {
    key: "getSvgDom",
    value: function getSvgDom(width, height, screenNum, scale, screenIdx) {
      var svgWidth = width / screenNum;
      return /*#__PURE__*/React.createElement("div", {
        className: "svg-content",
        key: screenIdx
      }, /*#__PURE__*/React.createElement("svg", {
        className: "svg-draw",
        style: {
          background: 'transparent'
        },
        width: svgWidth / scale,
        height: height / scale,
        viewBox: "0 0 ".concat(svgWidth, " ").concat(height)
      }, this.renderDrawData(screenIdx)));
    }
  }, {
    key: "render",
    value: function render() {
      var _this6 = this;

      var _this$props4 = this.props,
          _this$props4$width = _this$props4.width,
          width = _this$props4$width === void 0 ? 200 : _this$props4$width,
          _this$props4$height = _this$props4.height,
          height = _this$props4$height === void 0 ? 200 : _this$props4$height,
          screenNum = _this$props4.screenNum,
          screenIndex = _this$props4.screenIndex,
          scale = _this$props4.scale,
          _this$props4$source = _this$props4.source,
          source = _this$props4$source === void 0 ? 'view' : _this$props4$source;
      var screenArray = new Array(screenNum || 1).fill(1);
      var scNumber = this.props.screenNum;
      var operationWidth = Number(width) + (scNumber - 1) * 5;
      return /*#__PURE__*/React.createElement("div", {
        className: "svg-draw-wrap",
        ref: this.svgRef
      }, source !== 'view' && screenArray.length > 1 && /*#__PURE__*/React.createElement("div", {
        className: "tab-content"
      }, screenArray.map(function (item, index) {
        return /*#__PURE__*/React.createElement("div", {
          className: cx({
            active: index === screenIndex
          }),
          "data-index": index,
          key: index,
          onClick: _this6.tabChange
        }, "\u5C4F", index + 1);
      })), source !== 'view' && /*#__PURE__*/React.createElement("div", {
        className: "svg-operation",
        style: {
          width: "".concat(operationWidth, "px")
        }
      }, /*#__PURE__*/React.createElement("div", {
        className: "o-item h-left",
        onClick: this.handleSaveSvgHorizontalLeft
      }), /*#__PURE__*/React.createElement("div", {
        className: "o-item h-center",
        onClick: this.handleSaveSvgHorizontalCenter
      }), /*#__PURE__*/React.createElement("div", {
        className: "o-item h-right",
        onClick: this.handleSaveSvgHorizontalRight
      }), /*#__PURE__*/React.createElement("div", {
        className: "o-item v-top",
        onClick: this.handleSaveSvgVerticalTop
      }), /*#__PURE__*/React.createElement("div", {
        className: "o-item v-middle",
        onClick: this.handleSaveSvgVerticalMiddle
      }), /*#__PURE__*/React.createElement("div", {
        className: "o-item v-bottom",
        onClick: this.handleSaveSvgVerticalbottom
      }), /*#__PURE__*/React.createElement("div", {
        className: "flex1"
      }), /*#__PURE__*/React.createElement("div", {
        className: "o-item scale-plus",
        onClick: function onClick() {
          return _this6.handleSaveSvgScale(0.1);
        }
      }), /*#__PURE__*/React.createElement("div", {
        className: "o-item scale-reduce",
        onClick: function onClick() {
          return _this6.handleSaveSvgScale(-0.1);
        }
      }), /*#__PURE__*/React.createElement("div", {
        className: "o-item delete",
        onClick: this.handleSaveSvgDelete
      })), width == undefined && height == undefined ? /*#__PURE__*/React.createElement("div", {
        className: "firstchoose"
      }, "\u8BF7\u5148\u786E\u5B9A\u8BF1\u5BFC\u5C4F\u7684\u5C3A\u5BF8") : /*#__PURE__*/React.createElement("div", {
        className: "svg-container"
      }, screenArray.map(function (item, index) {
        return _this6.getSvgDom(width, height, screenNum, scale, index);
      })));
    }
  }]);

  return SvgEditor;
}(React.Component);

SvgEditor.propTypes = void 0;
SvgEditor.propTypes = {
  width: PropTypes.number,
  height: PropTypes.number,
  data: PropTypes.array,

  /**
   * @description 渲染模式
   * @default ''
   */
  source: PropTypes.string
};
export default SvgEditor;